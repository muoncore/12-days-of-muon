---
layout: documentation
title: Create a new Muon Stack
---
:toc:
:source-highlighter: pygments
:title: Create a Stack
:source-highlighter: pygments
:toc: right
:toc-title: Create a Stack
:toclevels: 6

:includedir: .
ifdef::env-doc[]
:includedir: guide/
endif::[]

## Create a new Muon Stack

A Stack is one of the central concepts of Muon, it lets you easily express communication as a series of messages and do so in a highly portable, straight forward way. As such, it lets you easily implement _Reactive_ architectural principles for Microservices and other types of distributed system (eg, browser/ server etc)

A Protocol Stack in Muon defines the message interchange that implements the communication you want (which we call a _Protocol_) and wraps that in a language idiomatic API to make it weasy to use.

### Stack Concepts

Muon takes the idea of _channels_ and makes them networked. In building a stack, your job is to assemble a set of channels, connect them together and decide what messages should flow over them, in what order, what they mean and what API should be used to interact with them.

When building a stack, you are designing both ends of the communication, not just a client or server.

Here is a standard stack showing the main components and where they come from.

.Stack Concepts
image::./images/stack-overview.png[]

In the above diagram, there are two portions to the stack, the client and the server. The only distinction between them is which initiates the connection between them. After the connection has been created, they are effective peers and can both send and receive messages as wanted, either can end the conversation and close the channel.

The APIs are exposed to application code, and so should take into the account the runtime and language that you are targetting. Inside the stack you will be using messaging and channel semantics, if your target developers are used to this you _could_ expose that directly. It is highly unlikely that this is actually what you want however, and so you should design an API that works for your developers and then map that internally onto messages coming from your protocol machines.

### Designing a new Stack

A stack is a message interchange, a conversation. The first thing you should do then is to design the messages and what they should express in a conversation. A messaging protocol is effectively a Finite State Machine, and so using the design approaches that are valid for FSM design will work well here. Once you have designed the messages, you can code up the Protocol machine to express those, then implement the API to manage the lifecycle of it all.

#### The Protocol

We will design a full featured protocol to interact with some remote systems. This fictional protocol we will call "continuous function".

Protocols in Muon are made up of messages following a standard schema. When passed to a transport, the schema is

[source,javascript]
----
{
    "target_service": "",
    "origin_service": "",
    "protocol": "",
    "step": "",
    "content_type": "application/json",
    "channel_op": "normal",  // or closed
    "payload": // byte array
}
----

This is all managed by Muon Core, which provides functions for creating messages and handling encoding/ decoding. To turn these into a functioning protocol, you decide what *step* messages you will have, and what payloads that will imply.

In our simple protocol, we will

* Send a message to a remote system with the step `RegisterFunction` that instructs the remote that it wants an answer to a question. The payload will contain a piece of text to test against and `X`, how often the answer should be sent back.
* The remote will send messages with the step `answer` and a payload containing a `text` property.
* Every X seconds, the remote will send back the answer.
* After Y answers, the client will close the connection, shutting down the conversation

This is kind of like RPC, but simpler and a long running aspect to it.

#### Building a Client API

The aim of building a Muon stack is to give a nice, user friendly API on top of distributed coordination/ messaging operation. You need to decide what this means for your API, such as whether it should be synchronous or not, the parameters and interactions that will happen.

In this case, we have an initial communication, passing the register text, along with how often you wish to be notified, and then some mechanism will be needed to pass the response back.

Here is an example API, which uses a simple method call and passes a callback function for async notification of results. The function will be invoked every time you get a response back. Consider other APIs you could provide, some synchronous option, or change to a streaming API using Reactive Streams or similar.

[source,java]
----
include::{includedir}/continuous-function/src/main/java/io/muoncore/example/ContinuousFunctionClient.java[]
----

This is implemented by creating a client class that takes the Muon object and uses the `TransportClient`. `Discovery`, `Codecs` and combining things together using Channels.

[source,java]
----
include::{includedir}/continuous-function/src/main/java/io/muoncore/example/protocol/continuousfunction/ContinuousClient.java[]
----


#### Building a Server API

Providing a Server Stack is slightly different. You still have a managing object, that implements `ServerProtocolStack`. This object is provided to Muon Core for it to manage the lifecycle of. It provides ChannnelConnections on demand.

The basic API of a `ServerProtocolStack` is

[source,java]
----
ProtocolDescriptor getProtocolDescriptor();                   <1>
Map<String, SchemaDescriptor> getSchemasFor(String endpoint);     <2>
ChannelConnection<MuonInboundMessage, MuonOutboundMessage> createChannel();  <3>
----
<1> Provide information about the stack for `introspection`.
<2> Optionally, provide schema/ type information, given a nominal endpoint, names of which will have been supplied in (1)
<3> Main function. Invoked by Muon Core whenever a new connection is opened for the protocol this stack provides.

Implementing this API is mostly about creating ChannelConnections and putting the Protocol behind them to trade messages with the client. You may notice that the `ChannelConnection` is the other way around in its generic information (MuonInbound vs Outbound), but that they otherwise match. The two channels are logically c

[source,java]
----
include::{includedir}/continuous-function/src/main/java/io/muoncore/example/protocol/continuousfunction/ContinuousServer.java[]
----


#### Building the Protocol Machines



TODO, pick the conversation


### Testing the Stacks


### Create a Stack for Muon Core Java



### Create a Stack for Muon Core Node



### Create a shared Protocol using JSProtocol

Implementing the message semantics above in every language that Muon is implemented in could quickly become onerous. For many protocols, that doesn't matter, they are inherently tied to a particular language or runtime. For the majority though their value is in their portability and being widely available.

To make this easier, we provide the ability to write the _Protocol_ once and have it run in a portable runtime. This runtime uses Javascript and is called the *JSProtocol*.

